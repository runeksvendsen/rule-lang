{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE FunctionalDependencies #-}
module Check.Type
( HasType(..)
)
where

import LangPrelude
import Absyn


type Env = Map Text

class HasType expr where
    exprType :: Env Type -> expr -> Either TypeError Type


instance HasType RuleExpr where
    exprType env expr =
        case expr of
            Let varName groupValueExpr ruleExpr -> do
                rhsType <- exprType env groupValueExpr
                exprType (insert env varName rhsType) ruleExpr

            Foreach groupValueExprField groupValueExprData ruleExpr ->
                let hasType = hasTypeAssert env
                in do groupValueExprField `hasType` [TypeFieldName]
                      groupValueExprData `hasType` [TypeGrouping]
                      exprType env ruleExpr

            Rule groupComparison -> do
                groupComparisonType env groupComparison
                return $ TypeFieldValue TypeBool

            And e1 exprList ->
                let hasType = hasTypeAssert env
                    bool = TypeFieldValue TypeBool
                in do e1 `hasType` [bool]
                      forM exprList (`hasType` [bool])
                      return bool

instance HasType Literal where
    exprType _ groupValue =
        let typ =
                case groupValue of
                    Integer _     -> TypeCount
                    Percent _   -> TypePercent
                    FieldName _ -> TypeFieldName
                    FieldValue v -> TypeFieldValue $ case v of
                        Number _    -> TypeNumber
                        String _    -> TypeString
                        Bool _      -> TypeBool
        in Right typ

instance HasType GroupValueExpr where
    exprType env expr =
        let aux (Literal groupValue) = (`exprType` groupValue)
            aux (DataExpr dataExpr)  = (`exprType` dataExpr)
            aux (GroupOp groupOp')   = (`exprType` groupOp')
            aux (Var varName')  = Right .
                fromMaybe (error $ "Variable '" ++ show varName' ++ "' not found") .
                lookup varName'
        in aux expr env

instance HasType DataExpr where
    exprType env expr =
        let hasType expr' typ = hasTypeAssert env expr' (nonEmpty typ)
        in case expr of
            GroupBy fieldValueExpr expr' -> do
                fieldValueExpr `hasType` TypeFieldName
                expr' `hasType` TypeGrouping
                Right TypeGrouping
            Filter filterComparison expr' -> do
                typeComparison env filterComparison
                expr' `hasType` TypeGrouping
                Right TypeGrouping

instance HasType GroupOp where
    exprType env expr =
        let hasType expr' expected = hasTypeAssert env expr' (nonEmpty expected)
        in case expr of
            GroupCount inputData -> do
                inputData `hasType` TypeGrouping
                Right TypeCount
            PositionFold _ fieldName inputData -> do
                fieldName `hasType` TypeFieldName
                inputData `hasType` TypeGrouping
                Right (TypeFieldValue TypeNumber)
            Relative groupOp relativeData -> do
                -- NB: Relative group count NOT supported
                _ <- groupOp `hasType` TypeFieldValue TypeNumber
                _ <- relativeData `hasType` TypeFieldName
                Right TypePercent

-- ##### Comparison types:
--  group comparison: (groupValueExpr-fieldName) (groupValueExpr-fieldName)
--    pos comparison: fieldName (fieldValue _)


groupComparisonType :: Env Type -> Comparison -> Either TypeError ()
groupComparisonType env (Comparison groupValueExprLeft bCompare groupValueExprRight) = do
    let hasType expr' = hasTypeAssert env expr'
    -- 'groupType1' must be present in the set of types
    --   that is supported by the given 'BoolCompare' operation
    groupType1 <- groupValueExprLeft `hasType` boolCompareTypes bCompare
    groupType2 <- exprType env groupValueExprRight
    if groupType2 /= groupType1
        then Left $ TypeError [groupType1] groupType2
        else Right ()

posComparisonType :: Env Type -> Comparison -> Either TypeError ()
posComparisonType env (Comparison fieldNameExpr bCompare fieldValueExpr) =
    let hasType input expected = hasTypeAssert env input expected
    in -- TODO: only enable e.g. >= on numbers
    do fieldNameExpr `hasType` [TypeFieldName]
       fieldValueExpr `hasType` boolCompareTypes bCompare
       return ()

-- | TODO
typeComparison :: Env Type -> Comparison -> Either TypeError ()
typeComparison env comp = error "TODO"
    -- use both pos & group

data Type =
      TypeCount     -- Generated by: 'GroupCount'
    | TypePercent   -- Generated by: 'Relative'
    | TypeGrouping  -- Generated by: 'DataExpr'
    | TypeFieldName -- Only for literals
    | TypeFieldValue TypeFieldValue
        deriving Eq

data TypeFieldValue =
      TypeNumber    -- Generated by: 'PositionFold'
    | TypeString
    | TypeBool
        deriving Eq

-- | The set of types for which equality is supported
equalityTypes :: NonEmpty Type
equalityTypes = [TypeCount, TypeFieldValue TypeString, TypeFieldValue TypeBool]

-- | The set of types for which "less/greater than" is supported
orderedTypes :: NonEmpty Type
orderedTypes = [TypeCount, TypePercent, TypeFieldValue TypeNumber]

-- | The set of types supported by the given 'BoolCompare' operation
boolCompareTypes :: BoolCompare -> NonEmpty Type
boolCompareTypes Eq   = equalityTypes
boolCompareTypes NEq  = equalityTypes
boolCompareTypes Lt   = orderedTypes
boolCompareTypes Gt   = orderedTypes
boolCompareTypes LtEq = orderedTypes
boolCompareTypes GtEq = orderedTypes

-- |
data TypeError = TypeError
    (NonEmpty Type) -- ^ Expected one of these types
    Type            -- ^ Found this type


--- ### Helper functions ###

hasTypeAssert
    :: HasType expr
    => Env Type
    -> expr
    -> NonEmpty Type
    -> Either TypeError Type
hasTypeAssert env expr expected = do
    actualType <- exprType env expr
    if not $ actualType `elem` expected
        then Left $ TypeError expected actualType
        else Right actualType
